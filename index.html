<!DOCTYPE html>
<html lang="en">
<head>
	<title>three</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		margin: 0px;
		overflow: hidden;
	}
	</style>
</head>
<body>
	<script src="three.js"></script>
	<script src="OrbitControls.js"></script>
	<script>

	'use strict';

	var w=20;
	var h=20;
	var depth=20;

	var grid=new Array(w);
	for(var x = 0; x<w; x++){
		grid[x]=new Array(h);
		for(var y = 0; y<h; y++){
			grid[x][y]=new Array(depth);
			for(var z = 0; z<depth; z++){
				grid[x][y][z]=0;
			}
		}
	}
	var path=[];
	var treesize=16;
	var start_positions=[8,8,8];
	var roots=[];
	function quadTree(){
		var depth=0;
		var startx=start_positions[0];
		var starty=start_positions[1];
		var startz=start_positions[2];
		grid[startx][starty][startz]+=1;
		roots.push([]);
		roots[0].push([startx,starty,startz]);
		roots.push([]);
		roots[1].push(growbranch(startx,starty,startz,treesize,1));
		while(true){
			var prev=depth;
			for(var a = 0; a<roots[0].length; a++){
				var posx=roots[0][a][0];
				var posy=roots[0][a][1];
				var posz=roots[0][a][2];
				var path=roots[1][a];
				search_opendirrs(posx,posy,posz,path);
			}
			depth=roots[0].length;
			if(prev==depth){
				break;
			}
		}
		return roots;
	}

	function search_opendirrs(posx, posy, posz, path){
		var openings=0;
		var skips=0;
		var dirr=-1;
		for(var x = 0; x<path.length; x++) {
			var dirr=path[x];
			var openings=0;
			for(var y = 0; y<6; y++){
				openings+=checkgrid2(posx,posy,posz,y);
			}
			if(openings<=2){
				skips+=1;
			}
			if(skips==3){
				for(var z =0; z<6; z++){
					if(checkgrid2(posx,posy,posz,z)==0){
						var newpath=growbranch(posx,posy,posz,treesize,z);
						roots[0].push([posx,posy,posz]);
						roots[1].push(newpath);
					}
				}
				return 0;
			}
			if(dirr==0){
				posy+=1
			}
			if(dirr==1){
				posx+=1
			}
			if(dirr==2){
				posy-=1
			}
			if(dirr==3){
				posx-=1;
			}
			if(dirr==4){
				posz+=1;
			}
			if(dirr==5){
				posz-=1;
			}
		}
	}

	function growbranch(posx, posy, posz, length, initdirr){
		var branch_path=[];
		var dirr=initdirr;
		for(var i = 0; i<length; i++) {
			var dirr=dont_turn_back(initdirr,dirr);
			if(i<8){
				dirr=initdirr;
			}
			var n=0;
			while(checkgrid2(posx,posy,posz,dirr)){
				if(n>100){
					return branch_path;
				}
				dirr=dont_turn_back(initdirr,dirr);
				n+=1;
			}
			if(dirr==0){
				posy+=1
			}
			if(dirr==1){
				posx+=1
			}
			if(dirr==2){
				posy-=1
			}
			if(dirr==3){
				posx-=1;
			}
			if(dirr==4){
				posz+=1;
			}
			if(dirr==5){
				posz-=1;
			}
			grid[posx][posy][posz]+=1;
			branch_path.push(dirr);
		}
		return branch_path;
	}

	//returns 1 if grid pos is taken
	function checkgrid2(posx,posy,posz,dirr){
		if(dirr==0){
			if(grid[posx][posy+1][posz]>0 || posy>h-3){
				return 1;
			}
			var two=0;
			for(var x = 0; x<6; x++){
				if(checkgrid3(posx,posy+1,posz,x)==1){
					two+=1;
				}
				if(two>1){
					return 1;
				}
			}
			return 0;
		}
		if(dirr==1){
			if(grid[posx+1][posy][posz]>0 || posx>w-3){
				return 1;
			}
			var two=0;
			for(var x = 0; x<6; x++){
				if(checkgrid3(posx+1,posy,posz,x)==1){
					two+=1;
				}
				if(two>1){
					return 1;
				}
			}
			return 0;
		}
		if(dirr==2){
			if(grid[posx][posy-1][posz]>0 || posy<2){
				return 1;
			}
			var two=0;
			for(var x = 0; x<6; x++){
				if(checkgrid3(posx,posy-1,posz,x)==1){
					two+=1;
				}
				if(two>1){
					return 1;
				}
			}
			return 0;
		}
		if(dirr==3){
			if(grid[posx-1][posy][posz]>0 || posx<2){
				return 1;
			}
			var two=0;
			for(var x = 0; x<6; x++){
				if(checkgrid3(posx-1,posy,posz,x)==1){
					two+=1;
				}
				if(two>1){
					return 1;
				}
			}
			return 0;
		}
		if(dirr==4){
			if(grid[posx][posy][posz+1]>0 || posz>depth-3){
				return 1;
			}
			var two=0;
			for(var x = 0; x<6; x++){
				if(checkgrid3(posx,posy,posz+1,x)==1){
					two+=1;
				}
				if(two>1){
					return 1;
				}
			}
			return 0;
		}
		if(dirr==5){
			if(grid[posx][posy][posz-1]>0 || posz<2){
				return 1;
			}
			var two=0;
			for(var x = 0; x<6; x++){
				if(checkgrid3(posx,posy,posz-1,x)==1){
					two+=1;
				}
				if(two>1){
					return 1;
				}
			}
			return 0;
		}
	}


	//returns 1 if grid pos is taken
	function checkgrid3(posx,posy,posz,dirr){
		if(dirr==0){
			if(posy<1){
				return 1;
			}
			if(grid[posx][posy+1][posz]>0){
				return 1;
			}	else { return 0;}
		}
		if(dirr==1){
			if(posy<1){
				return 1;
			}
			if(grid[posx+1][posy][posz]>0){
				return 1;
			}	else { return 0;}
		}
		if(dirr==2){
			if(posy<1){
				return 1;
			}
			if(grid[posx][posy-1][posz]>0){
				return 1;
			}	else { return 0;}
		}
		if(dirr==3){
			if(posy<1){
				return 1;
			}
			if(grid[posx-1][posy][posz]>0){
				return 1;
			}	else { return 0;}
		}
		if(dirr==4){
			if(posy<1){
				return 1;
			}
			if(grid[posx][posy][posz+1]>0){
				return 1;
			}	else { return 0;}
		}
		if(dirr==5){
			if(posy<1){
				return 1;
			}
			if(grid[posx][posy][posz-1]>0){
				return 1;
			}	else { return 0;}
		}
	}

	function dont_turn_back(initdirr,dirr){
		if(Math.random()<0.33){
			return initdirr;
		}
		return Math.floor(Math.random() * 6);
	}

	function getGrid(){
		return grid;
	}

	function top_left(){
		for(var x = 0; x<w; x++){
			for(var y = 0; y<h; y++){
				if(grid[y][x]){
					return x,y;
				}
			}
		}
		return -1;
	}

	//if back and forth continue, dont put
	quadTree();
	function drawGrid(){
		for(var x = 0; x<w; x++){
			for(var y = 0; y<h; y++){
				for(var z = 0; z<depth; z++){
					if(grid[x][y][z]==1){
						drawbox([x,y,z])
					}
				}
			}
		}
	}
	let scene, camera, renderer, controls;

	let particles, saturn, box, arr;
	arr =[];
	let width = window.innerWidth,
	height = window.innerHeight;

	const colors = [0x37BE95, 0xF3F3F3, 0x6549C0];

	init();
	animate();

	function init() {
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
		camera.lookAt(scene.position);
		camera.position.z = 200;

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(width, height);
		renderer.setClearColor(0x0E2255);
		renderer.shadowMap.enabled = true;

		controls = new THREE.OrbitControls(camera, renderer.domElement);

		const ambientLight = new THREE.AmbientLight();
		scene.add(ambientLight);

		const light = new THREE.DirectionalLight();
		light.position.set(200, 100, 200);
		light.castShadow = true;
		light.shadow.camera.left = -100;
		light.shadow.camera.right = 100;
		light.shadow.camera.top = 100;
		light.shadow.camera.bottom = -100;
		scene.add(light);

		document.body.appendChild(renderer.domElement);

		window.addEventListener('resize', onResize);
	}

	function onResize() {
		width = window.innerWidth;
		height = window.innerHeight;
		camera.aspect = width / height;
		camera.updateProjectionMatrix();
		renderer.setSize(width, height);
	}

	function animate() {
		requestAnimationFrame(animate);
		render();
	}

	var position = 20;
	var ler = 0.0;
	function render() {
		if(ler==0){
			drawGrid();
		}
		ler+=0.001;
		if(ler<.02){
			for(var x = 0; x<arr.length; x++){
				arr[x].material.color.lerp(new THREE.Color("rgb(255, 255, 0)"),ler);
			}
		}
		renderer.render(scene, camera);
	}

	function drawbox(pos) {
		box = new THREE.Group();
		scene.add(box);
		const boxGeo = new THREE.BoxGeometry(8,8,8);
		const boxMat = new THREE.MeshPhongMaterial({
			color: new THREE.Color("rgb(255, 0, 0)"),
			shading: THREE.FlatShading
		});
		const obj = new THREE.Mesh(boxGeo, boxMat);
		obj.castShadow = true;
		obj.receiveShadow = true;
		obj.position.set(pos[0]*8-(10*8), pos[1]*8-(10*8), pos[2]*8-(10*8));
		arr.push(obj);
		box.add(obj);
	}

	function drawParticles() {
		particles = new THREE.Group();
		scene.add(particles);
		const geometry = new THREE.TetrahedronGeometry(9, 0);

		for (let i = 0; i < 500; i ++) {
			const material = new THREE.MeshPhongMaterial({
				color: colors[Math.floor(Math.random() * colors.length)],
				shading: THREE.FlatShading
			});
			const mesh = new THREE.Mesh(geometry, material);
			mesh.position.set((Math.random() - 0.5) * 1000,
			(Math.random() - 0.5) * 1000,
			(Math.random() - 0.5) * 1000);
			mesh.updateMatrix();
			mesh.matrixAutoUpdate = false;
			particles.add(mesh);
		}
	}

	function drawSaturn() {
		saturn = new THREE.Group();
		saturn.rotation.set(0.4, 0.3, 0);
		scene.add(saturn);

		const planetGeometry = new THREE.BoxGeometry(10, 10);

		const planetMaterial = new THREE.MeshPhongMaterial({
			color: 0x37BE95,
			shading: THREE.FlatShading
		});
		const planet = new THREE.Mesh(planetGeometry, planetMaterial);

		planet.castShadow = true;
		planet.receiveShadow = true;
		planet.position.set(0, 40, 0);
		saturn.add(planet);

		const ringGeometry = new THREE.TorusGeometry(140, 12, 6, 15);
		const ringMeterial = new THREE.MeshStandardMaterial({
			color: 0x6549C0,
			shading: THREE.FlatShading
		});
		const ring = new THREE.Mesh(ringGeometry, ringMeterial);
		ring.position.set(0, 40, 0)
		ring.rotateX(80);
		ring.castShadow = true;
		ring.receiveShadow = true;
		saturn.add(ring);
	}

	</script>
</body>
</html>
